\chapter{DESAIN DAN IMPLEMENTASI}
\label{chap:desainimplementasi}


\section{Struktur Rencana Kerja Pengembangan (WBS)}
\sloppy
Penelitian ini menggunakan pendekatan pengembangan berbasis \emph{Work Breakdown Structure} (WBS), yaitu metode sistematis untuk membagi keseluruhan proses pengembangan ke dalam unit-unit kerja yang lebih kecil dan terstruktur. WBS mencakup tahapan analisis kebutuhan, perancangan, implementasi, hingga evaluasi, yang disusun secara hierarkis untuk memudahkan perencanaan dan pelaksanaan sistem secara efisien. Diagram WBS yang digunakan dalam penelitian ini dapat dilihat pada Gambar \ref{fig:wbs}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth]{gambar/bab3/wbs-ta.png}
  \caption{\emph{Work Breakdown Structure (WBS)} Penelitian}
  \label{fig:wbs}
\end{figure}

Pada gambar \ref{fig:wbs} struktur pengembangan sistem \emph{Quadruped Substation Monitoring}, yang terbagi menjadi empat tahap utama, yaitu \emph{Initiation}, \emph{Planning}, \emph{Production}, dan \emph{Testing and Evaluation}. Setiap tahap memiliki elemen-elemen yang lebih spesifik yang mendetailkan proses yang terlibat. Pada tahap \emph{Initiation}, dilakukan analisis terhadap kondisi eksisting, identifikasi masalah, dan penentuan deskripsi hasil yang diinginkan dari sistem yang akan dibangun. Proses ini merupakan fondasi awal untuk memastikan bahwa tujuan yang ingin dicapai jelas dan terukur. Selanjutnya, pada tahap \emph{Planning}, dilakukan perencanaan teknis yang mencakup desain kelistrikan dan perangkat lunak. Tahap ini melibatkan berbagai aspek, seperti pengembangan sistem komunikasi dan sistem daya, yang mendukung operasi sistem secara keseluruhan. Setelah tahap perencanaan selesai, tahap \emph{Production} dimulai, yang mencakup produksi kelistrikan dan pengembangan perangkat lunak. Proses ini juga melibatkan integrasi seluruh komponen sistem untuk memastikan semuanya berjalan sesuai rencana. Pada akhirnya, pada tahap \emph{Testing and Evaluation}, sistem diuji dengan berbagai metode, baik uji fungsional seperti \emph{API Testing} dan \emph{Unit Testing}, maupun uji non-fungsional seperti \emph{Performance Testing}. Evaluasi dilakukan untuk memastikan bahwa sistem yang dibangun memenuhi standar dan tujuan yang telah ditentukan. Diagram ini secara keseluruhan membantu menggambarkan bagaimana tahapan-tahapan dalam pengembangan sistem dibagi menjadi unit-unit yang lebih kecil untuk memastikan manajemen yang lebih baik, pemantauan yang efisien, dan pengelolaan sumber daya yang optimal dalam setiap fase pengembangan.


\section{Desain Pengembangan Sistem}
Pengembangan dalam penelitian ini bertujuan untuk melakukan otomatisasi proses pemantauan suhu komponen gardu induk yang sebelumnya dilakukan secara manual, dengan memanfaatkan robot berkaki empat \emph{(quadruped-legged)} Deep Robotics X30 Pro. Agar sistem mampu melakukan pemantauan secara otomatis, diperlukan pengembangan lebih lanjut dari kondisi robot yang ada saat ini. Pengembangan sistem ini mencakup tiga tujuan utama, yaitu: sistem deteksi suhu komponen, sistem navigasi otonom, dan sistem \emph{control station}. Melalui pengembangan ini, diharapkan robot dapat melakukan patroli secara mandiri di area gardu induk, mendeteksi komponen yang mengalami kondisi \emph{overheat}, serta menyampaikan informasi yang relevan kepada operator melalui sistem \emph{control station}. Dalam proses pengembangan ini, selain dilakukan pengembangan perangkat lunak robot, juga dilakukan integrasi perangkat keras tambahan seperti kamera termal, modul komunikasi nirkabel, dan perangkat lunak sebagai sistem \emph{control station} yang akan digunakan untuk memantau kondisi robot dan memberikan informasi terkait potensi \emph{overheat} secara \emph{real-time}. Sistem \emph{control station} ini dirancang untuk memungkinkan pengawasan yang lebih efisien dan pengambilan keputusan yang lebih cepat oleh operator, dengan menggunakan data yang diperoleh dari sensor termal robot yang dipantau terus menerus. Robot tidak hanya bertugas untuk mendeteksi suhu, tetapi juga harus memiliki kemampuan navigasi yang baik untuk bergerak secara otonom di area gardu induk yang kompleks, sehingga pengembangan sistem navigasi otonom juga menjadi bagian yang sangat penting dalam penelitian ini. 


\subsection{Desain Elektrikal}

Desain elektrikal robot mencakup perancangan sistem distribusi daya dan komunikasi yang bertujuan untuk mengintegrasikan komponen-komponen tambahan ke dalam sistem robot yang telah ada. Komponen tambahan ini dirancang untuk mendukung kapabilitas operasi otonom robot secara menyeluruh. Rancangan lengkap dari sistem dapat dilihat pada Gambar~\ref{fig:electrical}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.85\textwidth]{gambar/bab3/electrical-design.png}
  \caption{Desain Elektrikal Robot}
  \label{fig:electrical}
\end{figure}

Pada Gambar~\ref{fig:electrical}, ditunjukkan bahwa robot dilengkapi dengan sejumlah komponen tambahan guna mendukung fungsi pemantauan suhu secara otomatis. Komponen-komponen tersebut antara lain meliputi kamera termal Hikvision HM-TD5528T-15/W, router Doublecom DB6000FR-ANS, dan perangkat \emph{switch} jaringan. Seluruh perangkat tambahan ini memerlukan catu daya sebesar 24~VDC yang disuplai langsung dari port daya pada \emph{navigation host} robot, sehingga tidak memerlukan sumber daya eksternal tambahan. Dari sisi komunikasi internal, seluruh perangkat jaringan di dalam robot terhubung melalui \emph{switch} jaringan yang kemudian diintegrasikan ke dalam sistem utama robot melalui \emph{debug port}. Konfigurasi ini membentuk suatu jaringan lokal tertutup \emph{(closed local network)}. Untuk mendukung komunikasi eksternal antara robot dan sistem \emph{control station}, digunakan skema komunikasi nirkabel \emph{Point-to-Point} (PTP) pada frekuensi 5{,}8~GHz. Dalam konfigurasi ini, perangkat pemancar yang terpasang pada \emph{control station} (Doublecom DB6000ANLT90-FR) dikonfigurasi sebagai \emph{access point} (AP), sedangkan perangkat penerima yang berada pada sisi robot berfungsi sebagai \emph{station}. Skema ini memungkinkan terjadinya pertukaran data dua arah berkecepatan tinggi dengan latensi rendah, yang sangat krusial untuk mendukung transmisi data secara \emph{real-time}, 


\subsection{Desain Sistem \emph{Computer Vision}}

Sistem \emph{computer vision} yang dikembangkan bertujuan untuk mendeteksi jenis komponen gardu induk serta menganalisis suhunya guna mengidentifikasi potensi \emph{overheat}. Proses ini dilakukan melalui dua tahap utama, yaitu deteksi objek menggunakan model \emph{YOLO} dan deteksi suhu dari komponen yang terdeteksi. Deteksi objek pada citra termal dilakukan menggunakan model \emph{YOLOv8}, model ini dipilih karena kemampuannya dalam melakukan deteksi objek secara akurat dan cepat. Hal ini penting agar suhu tinggi yang terdeteksi benar-benar berasal dari komponen gardu, dan bukan objek lain di latar. Jika terdapat objek yang dideteksi, maka dilakukan konversi citra termal ke citra skala abu-abu (\emph{grayscale}) untuk memungkinkan pemetaan suhu berdasarkan intensitas piksel. Pemetaan suhu dilakukan dengan mengubah nilai intensitas piksel citra \emph{grayscale} menjadi nilai suhu aktual berdasarkan data konfigurasi suhu minimum dan maksimum yang diperoleh melalui ISAPI. Nilai suhu aktual dari area pada \emph{bounding box} hasil deteksi objek kemudian dibandingkan dengan ambang batas suhu berdasarkan jenis komponen. Jika melebihi batas tersebut, sistem menyimpulkan adanya potensi \emph{overheat}.

\subsection{Desain Perangkat Lunak Robot}
Desain perangkat lunak pada robot dilakukan dengan mempertimbangkan arsitektur perangkat lunak yang bersifat modular dan terintegrasi. Pendekatan ini bertujuan untuk mempermudah proses pengembangan, pemeliharaan, serta pengujian sistem secara menyeluruh. Dalam penelitian ini, perangkat lunak dibagi menjadi beberapa \textit{package} ROS yang masing-masing memiliki fungsi spesifik dan saling terhubung.

Terdapat empat \textit{package} utama yang dikembangkan, yaitu \textit{IO package}, \textit{Localization and Mapping package}, \textit{Autonomy package}, dan \textit{Perception package}. Struktur umum dari arsitektur perangkat lunak ini dapat dilihat pada Gambar~\ref{fig:software-arch}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/sotware-arch.png}
  \caption{Arsitektur Perangkat Lunak Robot}
  \label{fig:software-arch}
\end{figure}

Pada gambar \ref{fig:software-arch} terdapat empat \emph{package} utama. \emph{IO package} mengelola komunikasi dengan perangkat keras seperti kamera thermal dan kontrol PTZ. \emph{Localization and Mapping package} bertanggung jawab untuk pemetaan dan penentuan posisi robot menggunakan data dari sensor LiDAR dan IMU. \emph{Autonomy package} mengatur penghindaran rintangan dan kontrol patroli robot untuk navigasi otonom. \emph{Perception package} mendeteksi suhu \emph{overheat} menggunakan kamera thermal dan membantu robot dalam mengidentifikasi hambatan Setiap \textit{package} menjalankan fungsi tertentu dan saling berkomunikasi melalui mekanisme \textit{topic}, \textit{service}, atau \textit{action} sesuai dengan kebutuhan sistem.

\subsubsection{3.2.3.1 \emph{IO Package}}
\textit{IO package} bertanggung jawab untuk mengelola seluruh input dan output dari perangkat keras robot, yang dalam hal ini adalah kamera thermal. \textit{IO package} terdiri dari dua program utama, yaitu \textit{RTSP client} dan \textit{PTZ controller}.  \textit{RTSP client} berfungsi untuk menghubungkan kamera thermal dengan sistem robot dan mengubah aliran data menjadi \textit{rostopic} berupa \textit{compressed image}. Sementara itu, \textit{PTZ controller} digunakan untuk mengatur pergerakan \textit{pan-tilt-zoom (PTZ)} serta menerima status posisi \emph{PTZ} saat ini menggunakan protokol \emph{ISAPI}. Informasi ini kemudian digunakan untuk mengontrol pergerakan \emph{PTZ} secara dinamis, yang dipadukan dengan \textit{PID controller} untuk memperoleh kecepatan rotasi dan sudut target yang akurat.

\subsubsection{3.2.3.2 \emph{Localization and Mapping Package}}
\emph{Localization and Mapping Package} bertanggung jawab untuk melakukan estimasi posisi robot secara \emph{real-time} di dalam lingkungan serta memperbarui peta berdasarkan data sensor yang diterima. Dalam penelitian ini, sistem memanfaatkan empat buah sensor LiDAR Livox Mid-360 dan satu unit Yesense-IMU sebagai sumber data utama. Sistem ini mengimplementasikan berbagai metode \emph{localization} yang mencakup pendekatan berbasis \emph{odometry-only} maupun pendekatan berbasis \emph{Simultaneous Localization and Mapping} (SLAM). Dua metode pertama merupakan metode berbasis \emph{odometry-only}, yaitu \emph{FastLIO2} dan \emph{DLIO} (\emph{Direct LiDAR-Inertial Odometry}), yang melakukan estimasi posisi robot secara langsung berdasarkan integrasi data LiDAR dan IMU tanpa melakukan pemetaan lingkungan. Karena tidak membentuk peta, metode ini memiliki keterbatasan dalam hal inisialisasi di mana proses \emph{localization} harus selalu dimulai dari posisi awal yang sama setiap kali sistem dijalankan, sehingga tidak adaptif terhadap perubahan posisi awal robot. 

Metode ketiga dan keempat menggunakan konsep pemisahan antara proses \emph{mapping} dan \emph{localization} yang tetap terintegrasi sesuai prinsip \emph{frontend-backend} dalam sistem SLAM modern. Pada metode ketiga proses pemetaan dilakukan menggunakan \emph{FastLIO2} untuk menghasilkan representasi peta dua dimensi dalam bentuk \emph{grid-map}, yang kemudian dimanfaatkan oleh \emph{HDL Localization} untuk melakukan proses pelokalan. Pendekatan keempat menggunakan metode \emph{Fast-LIO-SAM} yang menggabungkan estimasi \emph{LiDAR-Inertial Odometry} (LIO) pada \emph{frontend} dengan proses optimisasi graf berbasis \emph{Smoothing and Mapping} (SAM) pada \emph{backend}, menghasilkan peta lingkungan tiga dimensi dalam format file \texttt{.bag} yang kemudian digunakan oleh \emph{Fast-LIO Localization QN} untuk proses \emph{localization}. Pada metode ketiga dan keempat, proses \emph{mapping} dan \emph{localization} tidak berjalan secara bersamaan sehingga memerlukan peta hasil pemetaan yang telah tersedia sebelum proses \emph{localization} dijalankan. Koordinat posisi robot yang dihasilkan dipublikasikan ke dalam sistem ROS melalui transformasi koordinat menggunakan modul \emph{tf broadcaster}.

\subsubsection{3.2.3.1 \emph{Perception Package}}
\emph{Perception package} bertanggung jawab untuk melakukan estimasi posisi komponen yang mengalami panas berlebih (\emph{overheat}) pada gardu induk. Proses ini dilakukan dengan meimplementasikan sistem \emph{computer vision} yang telah dijelaskan pada subbab 3.2.1.  Selain itu \emph{Perception package} juga mengelola deteksi rintangan yang dilakukan oleh robot. Sistem ini menggunakan algoritma \emph{Braitenberg} untuk mendeteksi dan menghindari rintangan di sekitar robot. Deteksi rintangan dilakukan dengan memanfaatkan sensor LiDAR yang terpasang pada robot, yang menghasilkan garis deteksi rintangan dalam sudut 180 derajat dari sisi kiri ke arah depan robot. Setiap garis deteksi memiliki bobot atau nilai \emph{multiplier} yang berbeda, yang digunakan untuk menilai tingkat risiko dan menentukan keputusan gerakan robot. Hasil  deteksi rintangan, akan diteruskan ke \emph{autonomy package} sebagai masukan untuk pengambilan keputusan navigasi secara otonom. Dengan pendekatan ini, sistem mampu melakukan deteksi serta identifikasi objek secara efisien, dan memberikan kontribusi penting dalam memastikan keselamatan serta efektivitas pergerakan robot di lingkungan nyata.

\subsubsection{3.2.3.2 \emph{Autonomy Package}}
Dalam sistem \emph{autonomy}, yang pada dasarnya merupakan proses navigasi jalur, lintasan robot diperoleh dari hasil perekaman \emph{path} yang dilakukan secara manual. Jalur ini kemudian disimpan dalam format \texttt{.json}. pada database \emph{control station}. Integrasi antara pengendalian lintasan dan penghindaran rintangan menjadi aspek yang krusial dalam sistem ini. Salah satu strategi yang umum digunakan adalah mengimplementasikan algoritma \emph{PID Pure Pursuit} sebagai pengendali utama lintasan, sementara modul penghindaran rintangan berbasis \emph{Braitenberg} diaktifkan secara kondisional ketika objek terdeteksi dalam jarak tertentu. Pendekatan ini memungkinkan robot untuk tetap mengikuti jalur yang telah direkam, namun tetap mampu bereaksi secara dinamis terhadap rintangan tanpa harus melakukan perencanaan ulang lintasan secara menyeluruh. Integrasi semacam ini dapat direalisasikan melalui skema \emph{behavior-based arbitration} atau \emph{subsumption architecture}, di mana modul penghindaran rintangan memiliki prioritas lebih tinggi ketika kondisi kritis terdeteksi. Setelah lingkungan kembali aman, kontrol akan dialihkan kembali ke pengendali lintasan utama. Selain navigasi jalur \emph{autonomy package} juga mengelola proses pengambilan gambar dari kamera termal yang terpasang pada robot. Proses ini dilakukan jika robot telah sampai pada titik koordinat tertentu yang telah ditentukan sebelumnya sistem akan mengirim perintah ke \emph{IO package} untuk mengerakan kamera termal ke posisi yang telah ditentukan. Setelah kamera berada pada posisi yang tepat, \emph{IO package} akan mengirim perintah ke \emph{RTSP client} untuk mengambil gambar dimana gambar yang diambil akan dikirim ke \emph{perception package} untuk dilakukan deteksi objek dan analisis suhu. 

\subsection{Desain \textit{Control Station}}

Sistem ini dirancang layaknya sebuah \emph{fleet management system} yang bertugas untuk memantau dan mengatur seluruh aktivitas operasional robot di lapangan secara \emph{real-time}. Fungsi utama dari sistem ini mencakup pemantauan posisi robot secara langsung pada peta, penyajian hasil deteksi suhu komponen serta visualisasi potensi \emph{overheat} pada komponen gardu, akses terhadap tampilan kamera langsung (\emph{live camera}), serta pengaturan dan penjadwalan jalur patroli. Perancangan \emph{control station} ini mengadopsi pendekatan berbasis web, sehingga dapat diakses dari berbagai perangkat secara fleksibel tanpa memerlukan instalasi tambahan. Hal ini penting untuk mendukung kebutuhan mobilitas operator di lapangan. 

\subsubsection{3.2.4.1 Perancangan \emph{User Interface}}

Tahap ini mencakup desain visual antarmuka, termasuk tata letak, elemen grafis, serta skema warna yang digunakan dalam sistem. Desain UI harus mempertimbangkan prinsip \emph{usability} dan \emph{user experience}, seperti konsistensi, umpan balik sistem, dan efisiensi interaksi. Selain itu, aspek estetika juga diperhatikan untuk mendukung kenyamanan visual dalam penggunaan jangka panjang. Penempatan elemen dirancang agar informasi kritis, seperti posisi robot, suhu komponen, dan status kamera, dapat diakses dengan cepat.Antarmuka juga dirancang agar mendukung tampilan multi-robot, memungkinkan operator memantau beberapa unit secara bersamaan. Navigasi antarmuka menggunakan pendekatan berbasis tab untuk menjaga keteraturan informasi. Berikut adalah desain antarmuka \emph{control station} yang telah dirancang:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/homepage.png}
  \caption{Desain halaman utama pada \emph{control station}}
  \label{fig:control-station-robot-main}
  \footnotesize{\textbf{Sumber:} Dokumentasi Penulis}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/robot-ui.png}
  \caption{Desain halaman manajemen robot pada \emph{control station}}
  \label{fig:control-station-robot-robot}
  \footnotesize{\textbf{Sumber:} Dokumentasi Penulis}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/component-ui.png}
  \caption{Desain halaman manajemen komponen gardu pada \emph{control station}}
  \label{fig:control-station-robot-patrol}
  \footnotesize{\textbf{Sumber:} Dokumentasi Penulis}
\end{figure}


\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/patrol-m.png}
  \caption{Desain halaman \emph{configurasi} jawdal patrol pada \emph{control station}}
  \label{fig:control-station-robot-settinq}
  \footnotesize{\textbf{Sumber:} Dokumentasi Penulis}
\end{figure}


\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/report.png}
  \caption{Desain halaman hasil deteksi overheat \emph{control station}}
  \label{fig:control-station-robot-feature}
  \footnotesize{\textbf{Sumber:} Dokumentasi Penulis}
\end{figure}


\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/user-ui.png}
  \caption{Desain halaman manajemen user pada \emph{control station}}
  \label{fig:control-station-robot-user}
  \footnotesize{\textbf{Sumber:} Dokumentasi Penulis}
\end{figure}






\subsubsection{3.2.4.2 \emph{Physical data model design}}
\emph{Physical data model design} berfokus pada strukturisasi dan organisasi data yang akan dikelola oleh sistem. Ini meliputi definisi entitas data seperti data robot, komponen gardu, route, riwayat patroli, user, dan informasi konfigurasi sistem. Perancangan ini juga mencakup penetapan relasi antar entitas dan tipe data untuk memastikan integritas dan efisiensi penyimpanan serta pengambilan data. Adapun \emph{physical data model} yang digunakan dalam sistem ini dapat dilihat pada Gambar~\ref{fig:physical-data-model}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.87\textwidth]{gambar/bab3/pdm.png}
  \caption{\emph{Physical Data Model} \emph{Control Station}}
  \label{fig:physical-data-model}
  \footnotesize{\textbf{Sumber:} Dokumentasi Penulis}
\end{figure}

Dari \emph{physical data model} \ref{fig:physical-data-model}, terlihat adanya entitas utama seperti \texttt{robots}, \texttt{patrol\_routes}, \texttt{patrol\_schedules}, dan \texttt{patrol\_sessions} yang merepresentasikan proses penjadwalan dan pelaksanaan patroli robot. Entitas \texttt{components} dan \texttt{component\_details} digunakan untuk menyimpan data komponen gardu yang dimonitor, termasuk jenis, lokasi pemasangan, serta parameter ambang batas suhu abnormal. Informasi jenis komponen disimpan dalam entitas \texttt{component\_types}. Deteksi suhu berlebih atau potensi overheat direkam dalam tabel \texttt{overheat\_detections}, yang terhubung dengan sesi patroli dan data komponen terkait. Posisi dan status robot secara waktu nyata dikelola melalui entitas \texttt{robot\_websockets}, yang mencatat data seperti posisi, arah, status sensor, dan kekuatan sinyal. Sistem ini juga mencakup manajemen pengguna dengan tabel \texttt{users} dan \texttt{refresh\_tokens} untuk kebutuhan autentikasi dan otorisasi. Informasi jenis robot disimpan dalam tabel \texttt{robot\_types}. Relasi antar tabel dirancang untuk mendukung integritas data dan efisiensi operasional sistem pemantauan dan pengendalian robot.

\subsubsection{3.2.4.3 \emph{Use case diagram}}
\emph{Use case diagram} digunakan untuk menggambarkan interaksi antara pengguna (aktor) dengan sistem. Diagram ini membantu dalam memahami kebutuhan fungsional sistem dan bagaimana pengguna akan berinteraksi dengan berbagai fitur yang disediakan. Berikut adalah \emph{use case diagram} yang menggambarkan interaksi antara pengguna dengan sistem \emph{control station}:

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/usecase.png}
  \caption{\emph{Use Case Diagram} \emph{Control Station}}
  \label{fig:use-case-diagram}
  \footnotesize{\textbf{Sumber:} Dokumentasi Penulis}
\end{figure}

Pada diagram tersebut terdapat tiga aktor, yaitu \texttt{User}, \texttt{Admin}, dan \texttt{Super Admin}, yang masing-masing memiliki tingkat akses berbeda terhadap sistem. Aktor \texttt{User} hanya memiliki akses untuk melihat data posisi dan data \emph{realtime} robot melalui fitur \texttt{View Realtime Data}, serta melihat data suhu berlebih melalui fitur \texttt{View Overheat Data}. Aktor \texttt{Admin} memiliki akses lebih luas, mencakup pengelolaan robot, komponen, dan jadwal patroli, serta melihat data anomali suhu, namun tidak memiliki wewenang untuk mengelola pengguna. Akses penuh terhadap seluruh fitur sistem, termasuk \texttt{Manage User}, hanya dimiliki oleh aktor \texttt{Super Admin}. Fitur \texttt{View Realtime Data} merupakan bagian dari \texttt{Manage Robot}, sedangkan \texttt{View Overheat Data} termasuk dalam \texttt{Manage Patrol}. Diagram ini menggambarkan batasan interaksi dan hak akses masing-masing aktor terhadap sistem \emph{Control Station}.


\section{Implementasi Sistem}
\sloppy
Implementasi sistem dilakukan dengan meimplementasikan rancangan yang telah dibuat pada tahap sebelumnya. Proses implementasi ini mencakup pengembangan perangkat lunak robot, integrasi perangkat keras, serta pengembagan sistem \emph{control station}.

\subsection{Implementasi Sistem \emph{Electrical}}
Implementasi sistem elektrikal dilakukan dengan mengintegrasikan komponen-komponen tambahan ke dalam robot yang telah ada. Proses ini meliputi pemasangan kamera termal, router nirkabel, dan perangkat \emph{switch} jaringan. Pemasangan dilakukan dengan memperhatikan skema distribusi daya yang telah dirancang sebelumnya, sehingga seluruh komponen dapat beroperasi dengan baik tanpa memerlukan sumber daya eksternal tambahan. Catu daya 24~VDC disuplai langsung dari port daya pada \emph{navigation host} robot seperti pada Gambar~\ref{fig:int-control-port}. 

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/int-control-port.png}
  \caption{Port pada \emph{Navigation Host} Robot  Tampak depan (atas) dan belakang (bawah)}
  \label{fig:int-control-port}
  \footnotesize{\textbf{Sumber:} Jueying X30 Pro Application Manual}
\end{figure}

Berdasarkan gambar di atas, dapat diketahui bahwa robot memiliki catu daya 24~VDC yang dapat digunakan untuk menyuplai perangkat tambahan. Berdasarkan data spesifikasi dari Deep Robotics X30 Pro, daya maksimum yang dapat disuplai oleh satu port 24~V adalah 240~W, atau dengan arus maksimum sebesar 10~A  Sementara itu perangkat tambahan yang digunakan terdiri dari:
\begin{enumerate}
  \item Kamera termal Hikvision HM-TD5528T-15/W dengan \emph{power consumption}  sebesar 20~W,
  \item Router nirkabel Doublecom DB6000FR-ANS dengan \emph{maximum power consumption} kurang dari 9~W,
  \item \emph{Switch} Moxa EDS-205  dengan \emph{input current 0.12~A} pada 24~VDC, sehingga daya yang dibutuhkan adalah 2.88~W
\end{enumerate}


Beradaskan data diatas total daya yang dibutuhkan oleh perangkat tambahan adalah:
\[
P_{\text{total}} = 20~W + 9~W + 2{,}88~W = 31{,}88~W
\]

Jika tegangan yang digunakan konstan 24~V, maka arus yang digunakan oleh perangkat tambahan adalah:
\[
I = \frac{P_{\text{total}}}{V} = \frac{31{,}88~W}{24~V} \approx 1{,}33~A
\]

Persentase penggunaan terhadap kapasitas maksimum port adalah:
\[
\text{Daya (\%P):} \quad \frac{31{,}88}{240} \times 100\% \approx 13{,}283333333\%
\]

Dengan demikian, total konsumsi daya dan arus perangkat tambahan hanya sekitar 13{,}3\% dari kapasitas maksimum port 24~V, sehingga masih berada dalam batas aman dan tidak membebani sistem catu daya robot. Selain sistem catu daya, implementasi ini juga mencakup konfigurasi komunikasi perangkat tambahan agar dapat diakses oleh robot. Dalam implementasinya, perangkat \emph{switch} Doublecom yang terpasang pada robot akan dihubungkan dengan perangkat \emph{switch} eksternal yang juga terhubung dengan kamera termal. Kedua \emph{switch} ini selanjutnya dihubungkan ke port jaringan pada robot. Seluruh perangkat dikonfigurasi dalam jaringan lokal dengan skema alamat IP yang sama, yaitu 192.168.1.\texttt{x}, sehingga dapat saling berkomunikasi tanpa melalui jaringan publik. Kamera termal, yang telah diatur menggunakan alamat IP statis 192.168.1.64, akan berada dalam satu segmen jaringan dengan router dan robot, memungkinkan akses data secara langsung melalui jalur Ethernet. Robot yang telah terintegrasi dengan komponen tambahan dapat dilihat pada gambar \ref{fig:sistem-elec-robot}


\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/impl-elec2.png}
  \caption{Integrasi robot dengan hardware external yang diperlukan}
  \label{fig:sistem-elec-robot}
  \footnotesize{\textbf{Sumber:} Dokumentasi Penulis}
\end{figure}

\subsection{Implementasi sistem \emph{computer vision}}
Pada tahap implementasi sistem \emph{computer vision}, dilakukan beberapa langkah utama yang mencakup pembuatan dataset, pelatihan model deteksi objek, konversi model ke format \emph{OpenVINO}, dan inferensi model untuk mendeteksi objek serta menganalisis suhu komponen gardu induk. Proses ini bertujuan untuk mengidentifikasi komponen gardu induk yang mengalami kondisi \emph{overheat} berdasarkan citra termal yang diambil oleh kamera termal yang terpasang pada robot.


\subsubsection{3.3.2.1 Pembuatan Dataset}
Dataset citra termal yang digunakan dalam penelitian ini berasal dari dua sumber utama. Dataset pertama diperoleh dari repositori publik \emph{Roboflow Universe}, yang menyediakan citra termal berbagai komponen gardu induk, seperti \emph{arrester}, \emph{breaker}, \emph{bushing}, \emph{clamp}, \emph{conservator}, \emph{current transformer}, \emph{disconnector}, \emph{heat sink}, \emph{insulator}, dan \emph{transformer}. Dataset kedua dikumpulkan secara langsung dari GITET (Gardu Induk Tegangan Ekstra Tinggi) PLN Gandul melalui proses perekaman video menggunakan kamera termal robot. Video hasil perekaman tersebut kemudian diunggah ke platform \emph{Roboflow}, yang secara otomatis mengkonversi video menjadi kumpulan citra (frame) individual. Citra-citra inilah yang selanjutnya digunakan sebagai dasar proses anotasi. Setiap komponen pada citra termal diberi label sesuai kelasnya, seperti \emph{current transformer}, \emph{circuit breaker}, maupun PMT (Pemutus tegangan gardu) seperti ditunjukkan pada Gambar~\ref{fig:dataset-annotated}. 
\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\textwidth]{gambar/bab3/dataset-anotated.png}
  \caption{Labeling dataset citra termal pada \emph{Roboflow}}
  \label{fig:dataset-annotated}
  \footnotesize{\textbf{Sumber:} Dokumentasi Penulis}
  \end{figure}
  
Proses anotasi ini krusial untuk memastikan model mampu mengenali dan mengklasifikasikan berbagai komponen gardu induk dengan akurat berdasarkan karakteristik citra termal. Dataset kemudian di bagi menjadi tiga bagian: data pelatihan, data validasi, dan data uji. Proporsi pembagian dataset adalah 70\% untuk pelatihan, 20\% untuk validasi, dan 10\% untuk pengujian. Pembagian ini bertujuan untuk memastikan model dapat belajar dengan baik dari data yang tersedia, serta menghindari overfitting pada saat pelatihan.

\subsubsection{3.3.2.2 \emph{Preprocessing} Dataset}
Setelah dataset citra termal dikumpulkan dan dianotasi, langkah selanjutnya adalah melakukan proses \emph{preprocessing} terhadap data tersebut. Pada penelitian ini, \emph{preprocessing} dilakukan dengan mengubah ukuran citra agar sesuai dengan format input yang dibutuhkan oleh model deteksi objek. Ukuran citra yang digunakan adalah 640$\times$480 piksel, yang merupakan standar umum untuk banyak arsitektur model deteksi seperti YOLO. Penyesuaian ukuran ini bertujuan untuk memastikan konsistensi data masukan, mempercepat proses pelatihan, serta meningkatkan performa dan akurasi model.


\subsubsection{3.3.2.3 \emph{Augmentasi} Data}
Untuk meningkatkan variasi data pelatihan dan mengurangi risiko \emph{overfitting}, dilakukan proses \emph{augmentasi} pada dataset citra termal. Proses ini menjadi sangat penting mengingat keterbatasan dalam pengambilan data lapangan secara langsung. Gardu induk merupakan objek vital nasional yang memiliki akses terbatas dan prosedur keamanan yang ketat, sehingga tidak memungkinkan untuk melakukan pengambilan data dalam jumlah besar secara bebas dan berulang. Oleh karena itu, augmentasi data digunakan untuk mensimulasikan berbagai kondisi nyata tanpa harus menambah data mentah secara langsung. Teknik augmentasi yang diterapkan meliputi \emph{Gaussian blur} untuk menyimulasikan kondisi citra buram akibat pergerakan atau gangguan fokus, penyesuaian tingkat kecerahan (\emph{brightness adjustment}) dan rona warna (\emph{hue adjustment}) untuk merepresentasikan variasi pencahayaan dan spektrum inframerah, serta \emph{horizontal flip} untuk menambah keragaman perspektif tampilan komponen. Sementara itu, \emph{vertical flip} tidak digunakan karena orientasi vertikal komponen gardu seperti trafo dan pemutus arus tidak mungkin berubah dalam kondisi nyata. Dengan pendekatan ini, model diharapkan tetap mampu belajar secara optimal meskipun jumlah data asli dari lapangan terbatas.

\subsubsection{3.3.2.4 Pelatihan Model \emph{YOLOv8}}

Model \emph{YOLOv8} dilatih menggunakan dataset citra termal yang telah melalui proses anotasi, \emph{preprocessing} dan \emph{augmentasi}. Selama proses pelatihan, dilakukan pengaturan terhadap beberapa \emph{hyperparameter} utama, yaitu \emph{batch size}, jumlah \emph{epoch}, dan algoritma \emph{optimizer}, guna memperoleh performa model yang optimal. sedangkan jumlah \emph{epoch} yang diuji bervariasi mulai dari 50, 100, 150, hingga 200. Untuk algoritma optimisasi, dilakukan perbandingan antara \emph{Stochastic Gradient Descent} (SGD) dan \emph{Adam Optimizer} guna melihat pengaruhnya terhadap kecepatan konvergensi dan stabilitas model.  Setelah proses pelatihan selesai, model dievaluasi menggunakan dataset uji yang telah dipisahkan sebelumnya untuk memastikan hasil validasi yang objektif dan menghindari risiko \emph{overfitting}. Evaluasi ini dilakukan dengan mengukur metrik seperti \emph{precision}, \emph{recall}, dan \emph{mAP (mean Average Precision)} guna mengetahui seberapa baik model dapat mendeteksi komponen gardu induk berdasarkan citra termal.


\subsubsection{3.3.2.5 Konversi ke \emph{OpenVINO}}
Setelah model \emph{YOLOv8} dilatih dan tervalidasi, tahap berikutnya adalah melakukan konversi ke format \emph{OpenVINO (Open Visual Inference and Neural Network Optimization)}. Konversi ini bertujuan untuk mengoptimalkan proses inferensi model agar dapat dijalankan secara efisien pada perangkat keras dengan sumber daya terbatas, khususnya yang berbasis CPU.

Dalam penelitian ini, sistem inferensi dirancang untuk dijalankan pada perangkat dengan prosesor Intel, sehingga penggunaan \emph{OpenVINO} menjadi pilihan ideal. \emph{OpenVINO} merupakan toolkit yang dikembangkan oleh Intel untuk mempercepat kinerja model \emph{deep learning} pada arsitektur CPU, GPU, dan VPU Intel. Dengan melakukan konversi model ke format \emph{Intermediate Representation (IR)} yang terdiri dari file \texttt{.xml} dan \texttt{.bin}, model dapat dieksekusi lebih ringan dan cepat, tanpa memerlukan akselerator eksternal seperti GPU.

\subsubsection{3.3.2.6 Inferensi Komponen}

Proses inferensi komponen dilakukan setelah robot tiba pada titik \emph{waypoint} tertentu dan mengambil citra termal menggunakan kamera yang terpasang. Citra tersebut kemudian diproses oleh model deteksi objek \emph{YOLOv8} yang telah dilatih dan dikonversi ke dalam format \emph{OpenVINO} agar dapat berjalan secara efisien di perangkat dengan prosesor Intel. Model ini melakukan deteksi pada citra termal untuk mengidentifikasi dan mengklasifikasikan komponen gardu induk seperti \emph{current transformer}, \emph{circuit breaker}, \emph{bushing}, dan komponen lainnya.

Hasil inferensi berupa koordinat \emph{bounding box} dan label kelas dari masing-masing objek yang terdeteksi. Informasi ini digunakan untuk menentukan area citra yang akan dianalisis lebih lanjut, khususnya dalam konteks pemantauan suhu untuk mendeteksi potensi \emph{overheat}. Proses inferensi ini dilakukan secara waktu nyata (\emph{real-time}) dan menjadi dasar bagi tahapan analisis suhu komponen yang lebih spesifik.

\subsubsection{3.3.2.7 Klasifikasi Suhu Komponen}

Setelah komponen berhasil terdeteksi, tahap berikutnya adalah mengklasifikasikan suhu dari masing-masing komponen berdasarkan area \emph{bounding box}. Langkah pertama dalam proses ini adalah mengonversi citra termal ke dalam format \emph{grayscale}, di mana setiap nilai intensitas piksel (0--255) mewakili tingkat suhu relatif. Nilai-nilai ini kemudian dikonversi ke suhu aktual berdasarkan rentang suhu minimum dan maksimum yang dikonfigurasi pada kamera.

Rentang suhu tersebut diperoleh menggunakan protokol ISAPI melalui endpoint berikut:

\begin{center}
\texttt{GET /ISAPI/Image/channels/<ID>/tempRange}
\end{center}

Endpoint ini digunakan untuk membaca parameter suhu dari kanal tertentu pada kamera, di mana \texttt{<ID>} mengacu pada nomor kanal kamera termal. Jika permintaan berhasil, kamera akan mengembalikan data dalam format XML yang memuat nilai suhu minimum dan maksimum seperti berikut:

\begin{lstlisting}[language=XML]
<?xml version="1.0" encoding="utf-8"?>
<TempRange version="2.0" xmlns="http://www.isapi.org/ver20/XMLSchema">
    <mode>manual</mode>
    <temperatureUpperLimit>100</temperatureUpperLimit>
    <temperatureLowerLimit>20</temperatureLowerLimit>
</TempRange>
\end{lstlisting}

Nilai intensitas piksel dalam area \emph{bounding box} kemudian dikonversi ke suhu aktual (\(T\)) menggunakan rumus berikut:

\begin{equation}
T(x, y) = T_{\text{min}} + \left( \frac{I(x, y)}{255} \right) \times (T_{\text{max}} - T_{\text{min}})
\label{eq:suhu-piksel}
\end{equation}


\noindent
dengan keterangan:
\begin{itemize}
  \item \( T(x, y) \): suhu piksel pada posisi \((x, y)\),
  \item \( I(x, y) \): nilai intensitas piksel (0â€“255),
  \item \( T_{\text{min}} \), \( T_{\text{max}} \): suhu minimum dan maksimum dari kamera.
\end{itemize}

Setelah nilai suhu pada seluruh piksel dalam \emph{bounding box} dihitung, suhu rata-rata komponen ditentukan menggunakan persamaan:

\begin{equation}
T_{\text{avg}} = \frac{1}{N} \sum_{i=1}^{N} T(x_i, y_i)
\label{eq:rata-rata-suhu}
\end{equation}

\noindent
dengan \( N \) adalah jumlah total piksel dalam area komponen. Nilai suhu rata-rata ini kemudian dibandingkan dengan ambang batas tertentu untuk menentukan apakah suatu komponen mengalami suhu berlebih (\emph{overheat}).

\subsection{Implementasi Sistem \emph{Perangkat Lunak Robot}}
Implementasi sistem perangkat lunak robot dilakukan dengan mengembangkan paket-paket ROS yang telah dirancang sebelumnya. Proses ini mencakup pengembangan \emph{IO package}, \emph{mapping package}, \emph{localization package}, \emph{perception package}, dan \emph{autonomy package}. Setiap \emph{package} dikembangkan dengan memperhatikan spesifikasi dan fungsionalitas yang telah ditetapkan pada tahap perancangan.

\subsubsection{3.4.3.1 Implementasi \emph{IO Package}}

\emph{IO package} bertanggung jawab untuk mengelola komunikasi antara robot dan perangkat keras eksternal, dalam hal ini adalah kamera termal. Package ini terdiri dari dua node utama, yaitu \emph{RTSP client} dan \emph{PTZ controller}.  Pada node \emph{RTSP client}, implementasi dilakukan menggunakan pustaka \emph{OpenCV} untuk menangani aliran video dari kamera termal. Node ini terhubung ke kamera melalui protokol \emph{RTSP}, mengambil frame video secara kontinu, dan meneruskannya ke node pada \emph{perception package} untuk proses deteksi objek dan analisis suhu. Selain itu, node ini juga mengelola pengaturan kamera seperti mengubah resolusi menjadi 640$\times$480 piksel, yang merupakan ukuran standar untuk model deteksi objek yang digunakan.

Node \emph{PTZ controller} bertugas mengendalikan pergerakan kamera termal, mencakup rotasi (\emph{pan}), kemiringan (\emph{tilt}), dan perbesaran (\emph{zoom}). Node ini menerima perintah dari \emph{Patrol Controller} melalui mekanisme \emph{action}  seperti ditunjukkan pada Gambar~\ref{fig:ptz-control}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/ptz-control.png}
  \caption{Diagram alur kerja \emph{PTZ controller node} dengan kendali \emph{PID}}
  \label{fig:ptz-control}
  \footnotesize{\emph{Sumber:} Dokumentasi Penulis}
\end{figure}

Dalam sistem ini \emph{Patrol Controller} bertindak sebagai \emph{action client} dan \emph{PTZ IO node} sebagai \emph{action server}. Komunikasi ini memungkinkan pengiriman \emph{goal}, umpan balik (\emph{feedback}), dan hasil akhir (\emph{result}). Di dalam \emph{PTZ IO node}, diterapkan kendali umpan balik berbasis \emph{PID controller} untuk memastikan pergerakan kamera menuju posisi target secara presisi dan stabil. Selisih antara posisi target (\emph{setpoint}) dan posisi aktual digunakan sebagai \emph{error}, yang kemudian diproses oleh tiga komponen \emph{PID}, yaitu \emph{proportional} (respon terhadap \emph{error} saat ini), \emph{integral} (koreksi terhadap akumulasi \emph{error}), dan \emph{derivative} (peredam perubahan mendadak). Keluaran dari \emph{PID controller} digunakan sebagai sinyal penggerak kamera. Dengan pendekatan ini, \emph{IO package} dapat mengintegrasikan sistem robot dengan kamera termal secara efisien,

\subsubsection{3.2.3.2 Implementasi Sistem \emph{Localization and Mapping Package}}

Implementasi sistem \emph{Localization and Mapping Package} dalam penelitian ini dirancang untuk mendukung fleksibilitas terhadap berbagai kondisi operasional di lapangan. Sistem dibangun secara modular dengan integrasi empat metode utama yang dapat diaktifkan melalui konfigurasi parameter pada berkas \texttt{launch} di ROS. Keempat metode tersebut terbagi ke dalam dua kelompok, yaitu metode berbasis \emph{odometry-only} dan metode berbasis \emph{SLAM}.

Pada kelompok pertama, metode \emph{FastLIO2} dan \emph{DLIO} digunakan untuk melakukan estimasi posisi robot secara langsung tanpa membentuk peta lingkungan. Masing-masing metode dijalankan sebagai \emph{node} ROS terpisah, yang menerima masukan berupa data \emph{point cloud} dari empat sensor \emph{LiDAR Livox Mid-360} serta data orientasi dan akselerasi dari sensor \emph{Yesense-IMU}. Hasil estimasi posisi dipublikasikan dalam sistem transformasi ROS melalui \emph{tf broadcaster} dan dapat digunakan oleh subsistem lain seperti navigasi dan kontrol.

Namun, pada saat implementasi, metode \emph{DLIO} tidak dapat dijalankan secara fungsional pada platform robot yang digunakan. Hal ini disebabkan oleh ketidaksesuaian \emph{timestamp} antara data \emph{LiDAR} dan \emph{IMU}, sedangkan \emph{DLIO} mensyaratkan sinkronisasi waktu yang presisi untuk melakukan \emph{sensor fusion}. Ketidaksesuaian tersebut mengakibatkan kegagalan pemrosesan internal pada \emph{node} \emph{DLIO}, sebagaimana ditunjukkan pada Gambar~\ref{fig:dlio-error}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{gambar/bab3/dlio-error.png}
  \caption{Kegagalan inisialisasi \emph{DLIO} akibat ketidaksesuaian \emph{timestamp}} 
  \label{fig:dlio-error}
  \footnotesize{\emph{Sumber:} Dokumentasi Penulis}
\end{figure}

Metode \emph{FastLIO2} diimplementasikan dengan memanfaatkan pustaka ROS yang telah tersedia dan diintegrasikan dengan sensor \emph{LiDAR} dan \emph{IMU} pada robot. Metode ini telah dioptimalkan untuk berjalan pada platform dengan sumber daya terbatas, seperti yang digunakan dalam penelitian ini. \emph{FastLIO2} berhasil diimplementasikan dan mampu beroperasi secara \emph{real-time} untuk mengestimasi posisi berdasarkan data \emph{point cloud} dari sensor \emph{LiDAR}. Estimasi posisi dihitung menggunakan algoritma \emph{LiDAR-Inertial Odometry}, dengan dukungan data dari \emph{IMU} untuk meningkatkan akurasi. Hasil estimasi posisi yang diperoleh dari metode ini ditunjukkan pada Gambar~\ref{fig:fastlio2-result}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/fastlio2-result.png}
  \caption{Hasil estimasi posisi robot menggunakan metode \emph{FastLIO2}}
  \label{fig:fastlio2-result}
  \footnotesize{\emph{Sumber:} Dokumentasi Penulis}
\end{figure}

Pada kelompok metode kedua yang berbasis \emph{SLAM}, implementasi dilakukan dengan pendekatan \emph{frontend-backend}. Pada metode ketiga, proses pemetaan dilakukan terlebih dahulu menggunakan \emph{FastLIO2} untuk membentuk peta dua dimensi dalam format \emph{grid map}. Peta ini kemudian dimuat oleh \emph{node} \emph{HDL Localization}, yang melakukan pelokalan secara \emph{real-time} dengan mencocokkan data \emph{point cloud} terhadap peta. Estimasi posisi robot dipublikasikan dalam bentuk transformasi dari kerangka \texttt{map} ke \texttt{base\_link} melalui sistem \emph{tf} ROS. Hasil peta dua dimensi ditunjukkan pada Gambar~\ref{fig:pgm}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{gambar/bab3/pgm.png}
  \caption{Peta \emph{grid map} hasil pemetaan menggunakan metode \emph{FastLIO2} dan digunakan oleh \emph{node} \emph{HDL Localization}}
  \label{fig:pgm}
  \footnotesize{\emph{Sumber:} Dokumentasi Penulis}
\end{figure}

Metode keempat, yaitu \emph{Fast-LIO-SAM}, menggabungkan estimasi \emph{LiDAR-Inertial Odometry} pada bagian \emph{frontend} dengan proses optimisasi graf berbasis \emph{Smoothing and Mapping (SAM)} pada bagian \emph{backend}. Selama proses pemetaan, data dari sensor direkam dalam format file \texttt{.bag} dan digunakan secara \emph{offline} oleh \emph{node} \emph{Fast-LIO Localization QN} untuk melakukan estimasi posisi. Node ini mencocokkan data \emph{point cloud} terbaru dengan peta yang telah terbentuk untuk memperkirakan posisi robot, kemudian menerbitkannya melalui \emph{tf broadcaster}. Hasil visualisasi peta 3D menunjukkan representasi struktur bangunan dan objek di sekitar robot secara detail, sebagaimana ditunjukkan pada Gambar~\ref{fig:fastlio-sam-map}.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\textwidth]{gambar/bab3/poincloud-map.png}  
  \caption{Visualisasi peta tiga dimensi hasil pemetaan menggunakan metode \emph{Fast-LIO-SAM}}
  \label{fig:fastlio-sam-map}
  \footnotesize{\emph{Sumber:} Dokumentasi Penulis}
\end{figure}


\subsubsection{3.4.3.3 Implementasi Sistem \emph{Perception Package}}

\emph{Perception package} bertanggung jawab untuk mendeteksi dan menganalisis komponen gardu induk berdasarkan citra termal dari kamera, serta mendeteksi rintangan di sekitar robot. Package ini terdiri dari dua node utama, yaitu \emph{Object Detection} dan \emph{Obstacle Detector}. Node \emph{Object Detection} mengimplementasikan model deteksi objek \emph{YOLOv8} yang telah dijelaskan pada bagian sebelumnya. Sementara itu, node \emph{Obstacle Detector} menggunakan algoritma \emph{Braitenberg Vehicle} untuk mendeteksi rintangan berdasarkan data dari sensor \emph{LiDAR}. Algoritma ini membagi area di depan robot menjadi 32 \emph{segment}. Setiap \emph{segment} dianalisis berdasarkan jarak terdekat yang terdeteksi oleh sensor \emph{LiDAR}. Jika jarak pada suatu \emph{segment} lebih kecil dari ambang batas tertentu, maka \emph{segment} tersebut dianggap sebagai rintangan. Informasi ini kemudian dikirimkan ke node \emph{Patrol Controller} untuk pengambilan keputusan pergerakan secara dinamis.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.6\textwidth]{gambar/bab3/obstacle-bb.png}
  \caption{Visualisasi \emph{Braitenberg Vehicle} kondisi terdapat rintangan (kanan) dan tanpa rintangan (kiri)}
  \label{fig:obstacle-detector}
  \footnotesize{\emph{Sumber:} Dokumentasi Penulis}
\end{figure}


\subsubsection{3.4.3.4 Implementasi Sistem \emph{Autonomy Package}}

Proses navigasi robot dilakukan dengan mengikuti jalur waypoint menggunakan algoritma \emph{Pure Pursuit} dan kontrol kecepatan berbasis \emph{PID controller}. Sistem ini juga memiliki kemampuan untuk melakukan inspeksi komponen secara otomatis ketika mencapai waypoint bertipe inspeksi, serta menghindari rintangan secara dinamis berdasarkan arsitektur perilaku (\emph{behavior-based arbitration}).

\begin{algorithm}[H]
\caption{Navigasi Waypoint dengan Pure Pursuit dan Subsumption Architecture}
\KwIn{Daftar \texttt{waypoints[]} dengan atribut \texttt{position, type}}
\KwOut{Navigasi dan inspeksi otomatis robot}
$i \gets 0$\;
\While{$i < \texttt{waypoints.length}$}{
    $\mathbf{w}_i \gets \texttt{waypoints}[i]$\;
    
    \While{\textbf{not} \texttt{isAtWaypoint}($\mathbf{w}_i$)}{
        \uIf{\texttt{detectObstacle()}}{
            \texttt{avoidObstacleBehavior()}\;
        }
        \Else{
            Hitung sudut arah relatif:\;
            \begin{equation}
            \alpha = \arctan2(y_{\text{target}} - y, x_{\text{target}} - x) - \theta
            \end{equation}
            Hitung sudut kemudi:\;
            \begin{equation}
            \delta = \arctan\left(\frac{2L \sin \alpha}{L_d}\right)
            \end{equation}
            Hitung error kecepatan:\;
            \begin{equation}
            e_v(t) = v_{\text{target}} - v(t)
            \end{equation}
            \begin{equation}
            v_{\text{cmd}} = K_p^v e_v(t) + K_i^v \int_0^t e_v(\tau)\, d\tau + K_d^v \frac{de_v(t)}{dt}
            \end{equation}
            Hitung error arah:\;
            \begin{equation}
            e_\delta(t) = \delta - \delta(t)
            \end{equation}
            \begin{equation}
            \omega_{\text{cmd}} = K_p^\delta e_\delta(t) + K_i^\delta \int_0^t e_\delta(\tau)\, d\tau + K_d^\delta \frac{de_\delta(t)}{dt}
            \end{equation}
            \texttt{publish}$(v_{\text{cmd}}, \omega_{\text{cmd}})$\;
        }
    }
    
    \If{$\mathbf{w}_i.\texttt{type} == \text{"inspection"}$}{
        $\texttt{ptz\_pose} \gets \texttt{getPTZPose}(\mathbf{w}_i)$\;
        \texttt{sendToPTZNode(ptz\_pose)}\;
        \texttt{sendCommandToCV("capture")}\;
        \uIf{\texttt{waitForCVResponse()} == "success"}{
            Lanjut ke waypoint berikutnya\;
        }
    }
    $i \gets i + 1$\;
}
\textbf{Navigasi selesai}\;
\end{algorithm}


\subsection{Implementasi Sistem \emph{Control Station}}
Sistem \emph{Control Station} diimplementasikan sebagai antarmuka pengguna berbasis web yang memungkinkan operator untuk mengendalikan robot, memantau statusnya, dan mengakses data yang dikumpulkan selama operasi. Implementasi sistem ini dapat dibagi menjadi dua komponen utama yaitu\emph{front-end} dan \emph{back-end}.

\subsubsection{3.4.4.1 Implementasi \emph{Frontend}}
Frontend dari sistem ini dibuat menggunakan library \textit{React} dan framework \textit{Next.js} untuk memberikan pengalaman pengguna yang cepat dan dinamis. Pemilihan \textit{React} didasarkan pada prinsip \textit{component-based architecture} yang memungkinkan pembuatan antarmuka pengguna dengan komponen-komponen modular yang dapat digunakan kembali. Hal ini mempercepat proses pengembangan dan mengurangi redundansi kode, karena pengembang dapat memanfaatkan kembali komponen yang sudah ada di berbagai bagian aplikasi. Sementara itu, \textit{Next.js} memperluas kemampuan \textit{React} dengan menambahkan fitur seperti \textit{server-side rendering} (SSR), \textit{static site generation}, dan routing berbasis file. Dengan menggunakan \textit{Next.js}, sistem ini dapat menghasilkan halaman yang lebih cepat dengan waktu pemuatan yang lebih singkat karena SSR memungkinkan konten halaman di-render di sisi server sebelum dikirimkan ke klien.

Untuk pengelolaan state, sistem ini menggunakan \textit{state management} dengan \texttt{Zustand}, sebuah library ringan dan efisien yang memungkinkan pengelolaan state secara sederhana dan terpusat tanpa memerlukan \textit{boilerplate code} seperti yang banyak seperti penggunaan reducer. Untuk pengambilan data dari server, aplikasi ini menggunakan \texttt{Tanstack Query}, yang mempermudah pengelolaan data, mendukung caching, dan menyediakan pembaruan data secara otomatis ketika ada perubahan. Sistem ini juga mengimplementasikan \textit{client-side filtering} dan \textit{server-side pagination}. \textit{Client-side filtering} memungkinkan data yang ditampilkan untuk difilter langsung di sisi klien, mempercepat proses pencarian, sementara \textit{server-side pagination} membagi data menjadi beberapa halaman, sehingga hanya sebagian data yang dimuat pada satu waktu, mengurangi beban pada server dan meningkatkan kinerja aplikasi. \textit{Server-side rendering} (SSR) yang didukung oleh \textit{Next.js} memungkinkan aplikasi untuk merender halaman di sisi server sebelum mengirimkannya ke klien, sehingga mempercepat waktu pemuatan halaman dan meningkatkan kemampuan mesin pencari untuk mengindeks halaman dengan lebih baik.

Untuk tampilan antarmuka pengguna (UI), aplikasi ini menggunakan \texttt{Shadcn UI} dan \texttt{Tailwind CSS}. \texttt{Shadcn UI} adalah pustaka komponen UI yang menyediakan elemen-elemen desain minimalis dan responsif, sementara \texttt{Tailwind CSS} memungkinkan pengembang untuk mendesain elemen-elemen UI dengan cepat menggunakan \textit{utility-first} CSS, sehingga memudahkan pembuatan tampilan yang responsif dan dinamis. Untuk manajemen autentikasi, aplikasi ini menggunakan cookies untuk menyimpan token autentikasi pengguna. Dengan menggunakan cookies, sesi pengguna dapat dipertahankan meskipun terjadi refresh halaman. Cookies ini bekerja dengan \textit{token JWT} untuk memverifikasi identitas pengguna dalam setiap permintaan ke server.  Berikut merupakan implementasi tampilan antarmuka pengguna pada \emph{control station} yang telah dirancang sebelumnya.



\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\textwidth]{gambar/bab3/fe/home.png}
  \caption{Implementasi desain halaman utama pada \emph{control station}}
  \label{fig:home-page}
  \footnotesize\emph{Sumber: Dokumentasi Penulis}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\textwidth]{gambar/bab3/fe/robot.png}
  \caption{Implementasi desain halaman manajemen robot pada \emph{control station}}
  \label{fig:robot-management}
  \footnotesize\emph{Sumber: Dokumentasi Penulis}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\textwidth]{gambar/bab3/fe/component.png}
  \caption{Implementasi desain halaman manajemen komponen gardu pada \emph{control station}}
  \label{fig:component-management}
  \footnotesize\emph{Sumber: Dokumentasi Penulis}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\textwidth]{gambar/bab3/fe/overheat.png}
  \caption{Implementasi desain halaman hasil deteksi overheat pada \emph{control station}}
  \label{fig:overheat-detection}
  \footnotesize\emph{Sumber: Dokumentasi Penulis}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.65\textwidth]{gambar/bab3/fe/user.png}
  \caption{Implementasi desain halaman manajemen user pada \emph{control station}}
  \label{fig:user-management}
  \footnotesize\emph{Sumber: Dokumentasi Penulis}
\end{figure}


\subsubsection{3.4.4.2 Implementasun Sistem Backend}

Sistem backend dari aplikasi ini dibuat menggunakan bahasa pemrograman \textit{TypeScript} dengan framework \textit{Express.js} untuk membangun RESTful API yang efisien dan mudah diakses. \textit{TypeScript} dipilih karena memberikan keunggulan dalam hal tipe data, yang memungkinkan pengembang untuk menulis kode yang lebih aman dan mudah dipelihara. Dengan menggunakan \textit{Express.js}, pengembangan API menjadi lebih cepat dan mudah, karena framework ini menyediakan berbagai fitur yang dibutuhkan untuk membangun aplikasi web dan API secara efisien. Untuk pengelolaan basis data, sistem ini menggunakan pustaka \texttt{Sequelize} sebagai \textit{Object-Relational Mapping} (ORM). \texttt{Sequelize} memungkinkan interaksi dengan basis data menggunakan model JavaScript yang lebih mudah dipahami dan dikelola, tanpa perlu menulis kueri SQL secara langsung. ORM ini menyediakan berbagai fitur seperti validasi data, relasi antar tabel, serta sistem migrasi untuk mempermudah pengelolaan skema dan konsistensi data aplikasi.

Dalam hal autentikasi, sistem menerapkan pendekatan berbasis \textit{JWT} (JSON Web Tokens) untuk login dan pengelolaan sesi. Pengguna yang berhasil melakukan autentikasi akan menerima \textit{access token} dan \textit{refresh token}. \textit{Access token} digunakan untuk mengakses endpoint API yang bersifat privat, sedangkan \textit{refresh token} memungkinkan pembaruan \textit{access token} yang telah kedaluwarsa tanpa perlu login ulang. Middleware \texttt{auth} digunakan untuk memverifikasi setiap token yang masuk dalam permintaan API, sehingga hanya pengguna yang telah terautentikasi yang dapat mengakses sumber daya tertentu. Sistem ini juga menerapkan \textit{Role-Based Access Control} (RBAC) untuk membatasi hak akses berdasarkan peran pengguna, seperti \textit{superadmin}, \textit{admin}, atau \textit{user}. Selain itu, fitur keamanan lintas domain dikendalikan melalui penerapan mekanisme \textit{CORS} (Cross-Origin Resource Sharing), yang memastikan bahwa hanya domain yang sah dan terverifikasi yang dapat berinteraksi dengan sistem API backend.

Untuk mendukung pengolahan data secara waktu nyata (\textit{real-time}), sistem ini menggunakan protokol \texttt{WebSocket}. Dengan WebSocket, koneksi dua arah (\textit{full-duplex}) antara klien dan server dapat terjaga secara terus-menerus, memungkinkan pengiriman data seperti posisi robot, status sensor, dan notifikasi sistem secara langsung tanpa perlu melakukan permintaan berulang (\textit{polling}). Pendekatan ini sangat penting untuk sistem pemantauan dan kontrol yang memerlukan latensi rendah dan pembaruan data secara instan. Sementara itu, untuk mendukung transmisi video langsung dari kamera robot ke antarmuka pengguna, sistem menggunakan protokol \texttt{WebRTC} (\textit{Web Real-Time Communication}). WebRTC memungkinkan komunikasi audio dan video secara peer-to-peer antara klien dan server, tanpa perlu plugin tambahan, serta mendukung kompresi dan pengiriman media dengan efisiensi tinggi. Penggunaan WebRTC memastikan bahwa tayangan video dari kamera robot dapat diakses secara langsung (\textit{live streaming}) dengan latensi rendah dan kualitas yang dapat disesuaikan secara adaptif sesuai kondisi jaringan.


\section{Integrasi Sistem}
Integrasi sistem dilakukan dengan menggabungkan seluruh komponen perangkat keras dan perangkat lunak yang telah dirancang untuk menciptakan sistem yang berjalan secara efisien dan terkoordinasi. Tahap pertama adalah integrasi komponen elektrikal, yang melibatkan pemasangan perangkat tambahan seperti kamera termal, router nirkabel, dan perangkat \emph{switch} jaringan pada robot. Komponen-komponen ini dihubungkan dengan catu daya 24 VDC dari port daya \emph{navigation host} robot, memastikan semua perangkat dapat beroperasi tanpa memerlukan sumber daya eksternal tambahan. Selanjutnya, perangkat-perangkat ini dikonfigurasi dalam jaringan lokal dengan alamat IP statis, memungkinkan komunikasi antar perangkat di dalam robot untuk mendukung fungsionalitas sistem. Untuk komunikasi antara \emph{control station} dan robot, digunakan skema komunikasi nirkabel \emph{Point-to-Point} (PTP). Pada \emph{control station}, router berfungsi sebagai \emph{access point} (AP) yang terhubung ke jaringan lokal robot. Sementara itu, pada robot, perangkat \emph{router} berfungsi sebagai \emph{station}, yang terhubung langsung dengan \emph{access point} yang ada di \emph{control station}. Konfigurasi ini memungkinkan pertukaran data dua arah berkecepatan tinggi antara robot dan \emph{control station}, dengan latensi rendah yang sangat krusial untuk mendukung transmisi data secara \emph{real-time}.

Setelah integrasi perangkat keras, sistem \emph{ROS} (Robot Operating System) diimplementasikan pada robot untuk mengelola komunikasi antar \textit{package} dan menjalankan berbagai fungsionalitas robot. ROS mengatur deteksi objek menggunakan model \emph{YOLO}, navigasi otonom, serta pemantauan suhu untuk mendeteksi potensi \emph{overheat}. Sistem ini memungkinkan integrasi komponen perangkat keras dan perangkat lunak dalam robot, dengan \emph{package}-package yang saling terhubung dan berkomunikasi untuk mencapai tujuan operasi otonom yang efisien.

Setelah robot terintegrasi dengan sistem ROS, \emph{control station} yang berbasis web diimplementasikan pada PC operator. \emph{Control station} memungkinkan operator untuk memantau dan mengendalikan robot secara \emph{real-time}, dengan antarmuka pengguna yang menyediakan akses mudah untuk memantau posisi robot, status sensor, dan hasil deteksi suhu berlebih pada komponen gardu induk. Di dalam \emph{control station}, operator dapat memasukkan data komponen gardu induk, termasuk jenis, lokasi, dan ambang batas suhu abnormal, yang kemudian terintegrasi dengan sistem. Dengan demikian, robot dan seluruh komponen gardu dapat terdaftar dan dipantau secara terpusat dalam satu sistem, yang memudahkan pengawasan dan pengendalian operasi robot di lapangan.

\section{Alur Kerja Sistem}

Alur kerja sistem dalam penelitian ini mencakup integrasi data komponen gardu induk, pembuatan rute, penentuan waypoint pada robot, serta pengaturan jadwal patroli yang terhubung dengan sistem \emph{control station}. Selain itu, terdapat pula mekanisme koreksi navigasi robot menggunakan metode \emph{Fast-LIO2} dan penghindaran rintangan untuk memastikan robot tetap pada jalur yang telah ditentukan. Proses ini dimulai dengan pengaturan data komponen hingga pengoperasian robot untuk patroli dan deteksi suhu berlebih pada komponen gardu induk. Berikut adalah penjelasan alur kerja secara rinci:

\subsection{Integrasi Data Komponen Gardu Induk}
Pada tahap awal, \emph{control station} menerima data komponen gardu induk yang mencakup informasi tentang nama kelas komponen, ambang batas suhu, serta posisi komponen yang terpasang di gardu induk. Data ini digunakan sebagai dasar bagi robot untuk mendeteksi suhu berlebih pada komponen gardu induk selama proses patroli. 

\subsection{Pembuatan Rute dan Waypoint di \emph{Control Station}}
Setelah data komponen terintegrasi, operator dapat membuat rute patroli di \emph{control station}. Rute ini terdiri dari serangkaian waypoint yang masing-masing berisi informasi tentang lokasi (X, Y), orientasi (Z), serta jenis waypoint (seperti \emph{start}, \emph{scan area}, atau \emph{dock charge}). Data waypoint ini kemudian dikirimkan ke robot dan digunakan untuk navigasi. Pada setiap waypoint, terdapat parameter tambahan yang digunakan untuk mengontrol pergerakan robot dan pengaturan kamera, seperti kecepatan (\emph{speed}), tipe gait (\emph{gaitType}), serta kontrol kamera seperti pan, tilt, dan zoom. Parameter ini memungkinkan robot untuk bergerak sesuai dengan yang diinginkan serta melakukan pemindaian atau deteksi suhu pada komponen gardu induk. Berikut adalah contoh format salah satu array waypoint yang digunakan dalam sistem:

\begin{lstlisting}
{
  "id": 6,
  "sequenceOrder": 0,
  "locationX": 10.5,
  "locationY": 20.3,
  "orientationZ": 45,
  "waypointType": "start",
  "gaitType": "walk",
  "speed": 0.5,
  "bodyHeight": 1.2,
  "cameraPan": 90,
  "cameraTilt": -10,
  "rgbCameraZoom": 1.5,
  "thermalCameraZoom": 2,
  "direction": "forward",
  "useObstacleAvoidance": true,
  "map": "route_1"
}
\end{lstlisting}

\subsection{Navigasi Robot}
Setelah waypoint dan rute ditentukan, robot dapat dijadwalkan untuk patroli pada waktu tertentu. Robot yang selalu terhubung dalam kondisi docking station akan melanjutkan patroli ke rute yang telah ditentukan pada waktu yang telah dijadwalkan. Selama patroli, robot bergerak menuju setiap waypoint secara berurutan, dengan mempertimbangkan kecepatan dan metode pergerakan yang telah diatur. Jika robot mendeteksi suhu berlebih pada komponen gardu induk, sistem akan melaporkan kondisi tersebut ke \emph{control station}.

\subsection{Deteksi Overheat dan Visualisasi pada \emph{Control Station}}
Robot dilengkapi dengan sistem deteksi suhu menggunakan kamera termal untuk memantau suhu komponen gardu induk. Jika robot mendeteksi adanya komponen yang mengalami suhu berlebih, kondisi tersebut akan dikirimkan ke \emph{control station}. Di \emph{control station}, informasi suhu berlebih akan divisualisasikan, dengan memperhitungkan posisi robot dan kelas komponen yang terdeteksi. Visualisasi ini memungkinkan operator untuk mengambil langkah segera jika terjadi overheat.

\subsection{Koreksi Posisi dengan \emph{Fast-LIO2}}
Selama patroli, robot dapat mengalami penyimpangan posisi atau kesalahan dalam estimasi lokasi akibat faktor lingkungan, misalnya perubahan medan atau ketidakakuratan sensor. Oleh karena itu, robot dilengkapi dengan \emph{Fast-LIO2} yang digunakan untuk memperbaiki posisi robot. Sistem ini mengintegrasikan data dari sensor LiDAR dan IMU untuk memperkirakan posisi robot secara akurat. Prediksi posisi robot pada waktu \( t \) dihitung menggunakan data IMU, sedangkan pencocokan data LiDAR dengan peta digunakan untuk memperbaiki estimasi posisi tersebut. Proses koreksi posisi ini dapat dijelaskan dengan persamaan berikut:

\begin{equation}
\mathbf{x}_t^{\text{updated}} = \mathbf{x}_t^{\text{pred}} + \mathbf{K} \cdot (\mathbf{z}_t - h(\mathbf{x}_t^{\text{pred}}))
\end{equation}

Di sini, \( \mathbf{x}_t^{\text{pred}} \) adalah posisi robot yang diprediksi berdasarkan data IMU, \( \mathbf{z}_t \) adalah data pengukuran LiDAR, dan \( \mathbf{K} \) adalah matriks gain dari pembaruan Kalman. Fungsi \( h(\mathbf{x}_t^{\text{pred}}) \) adalah model yang menghubungkan prediksi posisi robot dengan data pengukuran LiDAR. Proses koreksi posisi ini memungkinkan robot untuk memperbaiki estimasi posisi secara real-time dan menjaga akurasi navigasi.

\subsection{Penghindaran Rintangan dan Kembali ke Jalur}
Jika robot mendeteksi adanya rintangan selama patroli, sistem \emph{obstacle avoidance} akan mengaktifkan algoritma penghindaran untuk menghindari hambatan tersebut. Setelah rintangan terhindar, robot akan melanjutkan perjalanannya dan kembali ke jalur semula menggunakan \emph{Fast-LIO2} untuk memastikan robot tetap pada jalur yang telah ditentukan. Jika robot masih menyimpang setelah menghindari rintangan, sistem akan mengoreksi posisi dan arah robot untuk memastikan kembali ke jalur yang benar. Penghindaran rintangan diaktifkan secara otomatis melalui deteksi objek yang ada di sekitar robot. Data dari sensor LiDAR yang dipasang pada robot digunakan untuk mendeteksi objek di sekitarnya, dan algoritma \emph{Braitenberg} digunakan untuk menilai seberapa dekat objek dengan robot. Jika jarak objek terdeteksi lebih kecil dari ambang batas yang telah ditentukan, robot akan menyesuaikan jalurnya dan menghindari rintangan.

\subsection{Pengecekan Konfigurasi dan Kembali ke Posisi Awal}
Pada saat robot melakukan docking untuk pengisian daya, sistem akan memeriksa dan memperbarui konfigurasi yang diterima dari \emph{control station}. Perubahan konfigurasi, baik itu rute atau jadwal patroli, hanya dapat dilakukan ketika robot berada dalam kondisi \emph{idle} atau saat berada di \emph{dock station}. Hal ini memastikan bahwa perubahan tidak mengganggu patroli yang sedang berjalan. Setelah menyelesaikan patroli, robot akan kembali ke posisi awalnya. Rute yang telah dibuat harus mencakup titik awal dan titik akhir yang sama, sehingga robot dapat kembali ke tempat yang sama setelah menyelesaikan patroli. Dalam hal ini, sistem memastikan bahwa robot mengikuti jalur yang benar, melakukan koreksi posisi jika diperlukan, dan kembali ke titik awal setelah menyelesaikan tugasnya. Dengan alur kerja yang terstruktur ini, robot dapat melakukan patroli secara otomatis, memantau kondisi komponen gardu induk, dan mengatasi potensi overheat yang terjadi, sambil tetap mengikuti jalur yang telah ditentukan dengan akurasi tinggi.
